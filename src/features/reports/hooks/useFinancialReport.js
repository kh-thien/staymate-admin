import { useState, useEffect, useRef, useCallback } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useFinancialReport = (propertyId, periodType = "MONTHLY", autoGenerate = true, roomId = null, dateFilter = null) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);
  const isGeneratingRef = useRef(false);
  const lastPeriodType = useRef(periodType);
  const lastRoomId = useRef(roomId);

  // Reset auto-generate flag khi periodType hoáº·c roomId thay Ä‘á»•i
  useEffect(() => {
    if (lastPeriodType.current !== periodType || lastRoomId.current !== roomId) {
      hasAutoGenerated.current = false;
      isGeneratingRef.current = false;
      lastPeriodType.current = periodType;
      lastRoomId.current = roomId;
    }
  }, [periodType, roomId]);

  // Memoize fetchData vá»›i useCallback Ä‘á»ƒ trÃ¡nh re-create má»—i render
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Get existing summary data (with roomId filter if provided)
      const summaryData = await reportService.getFinancialSummary(
        propertyId,
        periodType,
        12,
        roomId,
        dateFilter // Pass date filter (selectedYear, selectedMonth, selectedQuarter)
      );

      // Náº¿u propertyId = null (táº¥t cáº£ properties) hoáº·c roomId Ä‘Æ°á»£c cung cáº¥p, khÃ´ng cáº§n auto-generate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
      // Náº¿u propertyId Ä‘Æ°á»£c cung cáº¥p vÃ  roomId = null (táº¥t cáº£ rooms), khÃ´ng cáº§n auto-generate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
      // Chá»‰ auto-generate khi sá»­ dá»¥ng financial_summary table (Ä‘Ã£ deprecated, nhÆ°ng giá»¯ láº¡i Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch)
      if (propertyId && !roomId && (!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current && !isGeneratingRef.current) {
        isGeneratingRef.current = true;
        hasAutoGenerated.current = true;
        
        // Tá»± Ä‘á»™ng táº¡o bÃ¡o cÃ¡o cho period hiá»‡n táº¡i
        const today = new Date();
        let startDate, endDate;

        switch (periodType) {
          case "WEEKLY":
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            startDate = weekStart.toISOString().split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "MONTHLY":
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "QUARTERLY":
            const quarterStartMonth = Math.floor(today.getMonth() / 3) * 3;
            startDate = new Date(today.getFullYear(), quarterStartMonth, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "YEARLY":
            startDate = new Date(today.getFullYear(), 0, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          default:
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
        }

        try {
          await reportService.generateFinancialReport(
            propertyId,
            startDate,
            endDate,
            periodType
          );
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getFinancialSummary(
            propertyId,
            periodType,
            12,
            roomId,
            dateFilter
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate report failed:", genError);
          // Náº¿u auto-generate fail, reset flag vÃ  set data rá»—ng
          hasAutoGenerated.current = false;
          setData([]);
        } finally {
          isGeneratingRef.current = false;
        }
      } else {
        setData(summaryData || []);
      }
    } catch (err) {
      console.error("Error fetching financial report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [propertyId, periodType, autoGenerate, roomId, dateFilter]);

  useEffect(() => {
    // Allow fetching when propertyId is null (all properties) or when propertyId is provided
    fetchData();
  }, [fetchData]); // fetchData is memoized with useCallback, so this is safe

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    // Subscribe to changes even when propertyId is null (all properties)
    // Realtime will trigger refetch for any bills/maintenance changes

    let refetchTimeout;
    let isMounted = true; // Track mount status to prevent setState after unmount

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      if (!isMounted) return; // Don't refetch if component is unmounted
      
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        if (!isMounted) return; // Double check before async operation
        // Khi cÃ³ thay Ä‘á»•i bills hoáº·c maintenance, tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o cho period hiá»‡n táº¡i
        const today = new Date();
        let startDate, endDate;

        switch (periodType) {
          case "WEEKLY":
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            startDate = weekStart.toISOString().split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "MONTHLY":
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "QUARTERLY":
            const quarterStartMonth = Math.floor(today.getMonth() / 3) * 3;
            startDate = new Date(today.getFullYear(), quarterStartMonth, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "YEARLY":
            startDate = new Date(today.getFullYear(), 0, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          default:
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
        }

        try {
          // Khi propertyId = null (táº¥t cáº£ properties) hoáº·c roomId Ä‘Æ°á»£c cung cáº¥p, 
          // khÃ´ng cáº§n regenerate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
          // Chá»‰ refresh data
          const updatedData = await reportService.getFinancialSummary(
            propertyId,
            periodType,
            12,
            roomId,
            dateFilter
          );
          if (isMounted) {
            setData(updatedData);
          }
        } catch (error) {
          console.error("Auto-refresh financial report failed:", error);
          // Náº¿u refresh fail, chá»‰ fetch data hiá»‡n cÃ³
          if (isMounted) {
            fetchData();
          }
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for financial report");

    const channelName = propertyId 
      ? `financial-report-${propertyId}-${periodType}-${roomId || 'all-rooms'}`
      : `financial-report-all-properties-${periodType}`;
    
    const channel = supabase.channel(channelName);

    // Get room IDs for property filtering (bills don't have property_id, only room_id)
    const setupRealtimeSubscription = async () => {
      let roomIdsForFilter = [];
      
    if (propertyId) {
        try {
          // Get all room IDs for this property
          const { data: rooms, error: roomsError } = await supabase
            .from("rooms")
            .select("id")
            .eq("property_id", propertyId)
            .is("deleted_at", null);
          
          if (!roomsError && rooms) {
            roomIdsForFilter = rooms.map(r => r.id);
          }
        } catch (error) {
          console.error("Error fetching rooms for realtime filter:", error);
        }
      }

      // Subscribe to bills changes with room filter
      if (propertyId && roomIdsForFilter.length > 0) {
        // Filter bills by room_id (since bills don't have property_id directly)
        // If roomId is specified, filter to that specific room
        const filterRoomIds = roomId ? [roomId] : roomIdsForFilter;
        
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "bills",
              filter: `room_id=in.(${filterRoomIds.join(',')})`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New bill created, refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "bills",
              filter: `room_id=in.(${filterRoomIds.join(',')})`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Bill updated, refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "DELETE",
            schema: "public",
            table: "bills",
              filter: `room_id=in.(${filterRoomIds.join(',')})`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Bill deleted, refreshing financial report");
            debouncedRefetch();
          }
        );
    } else {
        // For all properties (propertyId is null), listen to all bills (no filter)
        // Note: This will trigger for all bills, but we'll filter in the callback if needed
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "bills",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New bill created (all properties), refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "bills",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Bill updated (all properties), refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "DELETE",
            schema: "public",
            table: "bills",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Bill deleted (all properties), refreshing financial report");
            debouncedRefetch();
          }
        );
    }

    // Subscribe to maintenance changes with property filter
      // Maintenance table has property_id, so we can filter directly
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New maintenance created, refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance updated, refreshing financial report");
            debouncedRefetch();
          }
        );
    } else {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New maintenance created (all properties), refreshing financial report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance updated (all properties), refreshing financial report");
            debouncedRefetch();
          }
        );
    }

    // Subscribe to bill_items changes
      // Note: bill_items don't have property_id or room_id, so we need to listen to all
      // This is a limitation - we'll refresh anyway but it's less efficient
    channel.on(
      "postgres_changes",
      {
        event: "*", // Listen for INSERT, UPDATE, DELETE
        schema: "public",
        table: "bill_items",
      },
      async (payload) => {
          // For bill_items, we can't filter by property/room in the subscription
          // We'll refresh anyway - the debounce will prevent excessive calls
        console.log("ðŸ”” REALTIME: Bill item changed, refreshing financial report");
        debouncedRefetch();
      }
    );

    // Only subscribe to financial_summary changes if propertyId is provided
    // (because financial_summary is property-specific and we calculate from bills directly when propertyId is null)
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "financial_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New financial summary created");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "financial_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Financial summary updated");
            fetchData();
          }
        );
    }

    channel.subscribe((status) => {
        if (status === "SUBSCRIBED") {
          console.log("âœ… Financial report realtime connected");
        } else if (status === "CHANNEL_ERROR") {
          console.error("âŒ Financial report realtime error");
        }
      });
    };

    // Setup the subscription
    setupRealtimeSubscription();

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up financial report realtime subscription");
      isMounted = false; // Mark as unmounted
      clearTimeout(refetchTimeout); // Clear any pending timeouts
      supabase.removeChannel(channel);
    };
  }, [propertyId, periodType, roomId, fetchData, dateFilter]);

  const generateReport = async (startDate, endDate, type = periodType) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateFinancialReport(
        propertyId,
        startDate,
        endDate,
        type
      );

      // Refresh data after generation
      const updatedData = await reportService.getFinancialSummary(
        propertyId,
        type,
        12,
        roomId,
        dateFilter
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating financial report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getFinancialSummary(
        propertyId,
        periodType,
        12,
        roomId,
        dateFilter
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing financial report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
