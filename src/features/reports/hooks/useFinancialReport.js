import { useState, useEffect, useRef } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useFinancialReport = (propertyId, periodType = "MONTHLY", autoGenerate = true, roomId = null) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);
  const lastPeriodType = useRef(periodType);
  const lastRoomId = useRef(roomId);

  // Reset auto-generate flag khi periodType hoáº·c roomId thay Ä‘á»•i
  useEffect(() => {
    if (lastPeriodType.current !== periodType || lastRoomId.current !== roomId) {
      hasAutoGenerated.current = false;
      lastPeriodType.current = periodType;
      lastRoomId.current = roomId;
    }
  }, [periodType, roomId]);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);

      // Get existing summary data (with roomId filter if provided)
      const summaryData = await reportService.getFinancialSummary(
        propertyId,
        periodType,
        12,
        roomId
      );

      // Náº¿u propertyId = null (táº¥t cáº£ properties) hoáº·c roomId Ä‘Æ°á»£c cung cáº¥p, khÃ´ng cáº§n auto-generate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
      // Náº¿u propertyId Ä‘Æ°á»£c cung cáº¥p vÃ  roomId = null (táº¥t cáº£ rooms), khÃ´ng cáº§n auto-generate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
      // Chá»‰ auto-generate khi sá»­ dá»¥ng financial_summary table (Ä‘Ã£ deprecated, nhÆ°ng giá»¯ láº¡i Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch)
      if (propertyId && !roomId && (!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current) {
        hasAutoGenerated.current = true;
        
        // Tá»± Ä‘á»™ng táº¡o bÃ¡o cÃ¡o cho period hiá»‡n táº¡i
        const today = new Date();
        let startDate, endDate;

        switch (periodType) {
          case "WEEKLY":
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            startDate = weekStart.toISOString().split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "MONTHLY":
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "QUARTERLY":
            const quarterStartMonth = Math.floor(today.getMonth() / 3) * 3;
            startDate = new Date(today.getFullYear(), quarterStartMonth, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "YEARLY":
            startDate = new Date(today.getFullYear(), 0, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          default:
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
        }

        try {
          await reportService.generateFinancialReport(
            propertyId,
            startDate,
            endDate,
            periodType
          );
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getFinancialSummary(
            propertyId,
            periodType,
            12,
            roomId
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate report failed:", genError);
          // Náº¿u auto-generate fail, váº«n set data rá»—ng Ä‘á»ƒ hiá»ƒn thá»‹ UI
          setData([]);
        }
      } else {
        setData(summaryData || []);
      }
    } catch (err) {
      console.error("Error fetching financial report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Allow fetching when propertyId is null (all properties) or when propertyId is provided
    fetchData();
  }, [propertyId, periodType, autoGenerate, roomId]);

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    // Subscribe to changes even when propertyId is null (all properties)
    // Realtime will trigger refetch for any bills/maintenance changes

    let refetchTimeout;

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        // Khi cÃ³ thay Ä‘á»•i bills hoáº·c maintenance, tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o cho period hiá»‡n táº¡i
        const today = new Date();
        let startDate, endDate;

        switch (periodType) {
          case "WEEKLY":
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            startDate = weekStart.toISOString().split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "MONTHLY":
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "QUARTERLY":
            const quarterStartMonth = Math.floor(today.getMonth() / 3) * 3;
            startDate = new Date(today.getFullYear(), quarterStartMonth, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          case "YEARLY":
            startDate = new Date(today.getFullYear(), 0, 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
            break;
          default:
            startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            endDate = today.toISOString().split("T")[0];
        }

        try {
          // Khi propertyId = null (táº¥t cáº£ properties) hoáº·c roomId Ä‘Æ°á»£c cung cáº¥p, 
          // khÃ´ng cáº§n regenerate vÃ¬ Ä‘Ã£ tÃ­nh tá»« bills trá»±c tiáº¿p
          // Chá»‰ refresh data
          const updatedData = await reportService.getFinancialSummary(
            propertyId,
            periodType,
            12,
            roomId
          );
          setData(updatedData);
        } catch (error) {
          console.error("Auto-refresh financial report failed:", error);
          // Náº¿u refresh fail, chá»‰ fetch data hiá»‡n cÃ³
          fetchData();
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for financial report");

    const channelName = propertyId 
      ? `financial-report-${propertyId}-${periodType}-${roomId || 'all-rooms'}`
      : `financial-report-all-properties-${periodType}`;
    
    const channel = supabase
      .channel(channelName)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "bills",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: New bill created, refreshing financial report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "bills",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Bill updated, refreshing financial report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "bills",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Bill deleted, refreshing financial report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "maintenance",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: New maintenance created, refreshing financial report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "maintenance",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance updated, refreshing financial report");
          debouncedRefetch();
        }
      );

    // Only subscribe to financial_summary changes if propertyId is provided
    // (because financial_summary is property-specific and we calculate from bills directly when propertyId is null)
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "financial_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New financial summary created");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "financial_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Financial summary updated");
            fetchData();
          }
        );
    }

    channel.subscribe((status) => {
        if (status === "SUBSCRIBED") {
          console.log("âœ… Financial report realtime connected");
        } else if (status === "CHANNEL_ERROR") {
          console.error("âŒ Financial report realtime error");
        }
      });

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up financial report realtime subscription");
      clearTimeout(refetchTimeout);
      supabase.removeChannel(channel);
    };
  }, [propertyId, periodType, roomId]);

  const generateReport = async (startDate, endDate, type = periodType) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateFinancialReport(
        propertyId,
        startDate,
        endDate,
        type
      );

      // Refresh data after generation
      const updatedData = await reportService.getFinancialSummary(
        propertyId,
        type,
        12,
        roomId
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating financial report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getFinancialSummary(
        propertyId,
        periodType,
        12,
        roomId
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing financial report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
