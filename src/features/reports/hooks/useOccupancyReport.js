import { useState, useEffect, useRef, useCallback } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useOccupancyReport = (propertyId, limit = 30, autoGenerate = true) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);
  const isGeneratingRef = useRef(false);

  // Memoize fetchData vá»›i useCallback
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const summaryData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );

      // Náº¿u chÆ°a cÃ³ dá»¯ liá»‡u vÃ  cho phÃ©p auto-generate, tá»± Ä‘á»™ng táº¡o bÃ¡o cÃ¡o
      if ((!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current && !isGeneratingRef.current) {
        isGeneratingRef.current = true;
        hasAutoGenerated.current = true;
        
        try {
          const today = new Date().toISOString().split("T")[0];
          await reportService.generateOccupancyReport(propertyId, today);
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getOccupancySummary(
            propertyId,
            limit
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate occupancy report failed:", genError);
          hasAutoGenerated.current = false;
          setData([]);
        } finally {
          isGeneratingRef.current = false;
        }
      } else {
        setData(summaryData);
      }
    } catch (err) {
      console.error("Error fetching occupancy report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [propertyId, limit, autoGenerate]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    let refetchTimeout;
    let isMounted = true; // Track mount status

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      if (!isMounted) return;
      
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        if (!isMounted) return;
        
        // Tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o khi cÃ³ thay Ä‘á»•i (chá»‰ khi cÃ³ propertyId)
        if (propertyId) {
          try {
            const today = new Date().toISOString().split("T")[0];
            await reportService.generateOccupancyReport(propertyId, today);
            
            // Fetch láº¡i sau khi regenerate
            const updatedData = await reportService.getOccupancySummary(
              propertyId,
              limit
            );
            if (isMounted) {
              setData(updatedData);
            }
          } catch (error) {
            console.error("Auto-regenerate occupancy report failed:", error);
            // Náº¿u regenerate fail, chá»‰ refresh data hiá»‡n cÃ³
            if (isMounted) {
              fetchData();
            }
          }
        } else {
          // For all properties, just refresh data (no regenerate needed)
          if (isMounted) {
            fetchData();
          }
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for occupancy report");

    const channelName = propertyId 
      ? `occupancy-report-${propertyId}`
      : `occupancy-report-all-properties`;
    
    const channel = supabase.channel(channelName);

    // Subscribe to rooms changes with property filter
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "rooms",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Room created, refreshing occupancy report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "rooms",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Room updated, refreshing occupancy report");
            debouncedRefetch();
          }
        );
    } else {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "rooms",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Room created (all properties), refreshing occupancy report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "rooms",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Room updated (all properties), refreshing occupancy report");
            debouncedRefetch();
          }
        );
    }

    // Subscribe to contracts changes
    // Note: contracts don't have property_id, so we listen to all and filter in callback if needed
    channel
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "contracts",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Contract created, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "contracts",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Contract updated, refreshing occupancy report");
          debouncedRefetch();
        }
      );

    // Subscribe to tenants changes
    channel
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "tenants",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Tenant created, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "tenants",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Tenant updated, refreshing occupancy report");
          debouncedRefetch();
        }
      );

    // Subscribe to occupancy_summary changes
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "occupancy_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New occupancy summary created");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "occupancy_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Occupancy summary updated");
            fetchData();
          }
        );
    } else {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "occupancy_summary",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New occupancy summary created (all properties)");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "occupancy_summary",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Occupancy summary updated (all properties)");
            fetchData();
          }
        );
    }

    channel.subscribe((status) => {
      if (status === "SUBSCRIBED") {
        console.log("âœ… Occupancy report realtime connected");
      } else if (status === "CHANNEL_ERROR") {
        console.error("âŒ Occupancy report realtime error");
      }
    });

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up occupancy report realtime subscription");
      isMounted = false;
      clearTimeout(refetchTimeout);
      supabase.removeChannel(channel);
    };
  }, [propertyId, limit, fetchData]); // Removed propertyId check - now supports all properties

  const generateReport = async (reportDate = null) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateOccupancyReport(propertyId, reportDate);

      // Refresh data after generation
      const updatedData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating occupancy report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing occupancy report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
