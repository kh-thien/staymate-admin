import { useState, useEffect, useRef } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useOccupancyReport = (propertyId, limit = 30, autoGenerate = true) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);

      const summaryData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );

      // Náº¿u chÆ°a cÃ³ dá»¯ liá»‡u vÃ  cho phÃ©p auto-generate, tá»± Ä‘á»™ng táº¡o bÃ¡o cÃ¡o
      if ((!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current) {
        hasAutoGenerated.current = true;
        
        try {
          const today = new Date().toISOString().split("T")[0];
          await reportService.generateOccupancyReport(propertyId, today);
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getOccupancySummary(
            propertyId,
            limit
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate occupancy report failed:", genError);
          setData([]);
        }
      } else {
        setData(summaryData);
      }
    } catch (err) {
      console.error("Error fetching occupancy report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!propertyId) {
      setLoading(false);
      return;
    }

    fetchData();
  }, [propertyId, limit, autoGenerate]);

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    if (!propertyId) return;

    let refetchTimeout;

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        // Tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o khi cÃ³ thay Ä‘á»•i
        try {
          const today = new Date().toISOString().split("T")[0];
          await reportService.generateOccupancyReport(propertyId, today);
          
          // Fetch láº¡i sau khi regenerate
          const updatedData = await reportService.getOccupancySummary(
            propertyId,
            limit
          );
          setData(updatedData);
        } catch (error) {
          console.error("Auto-regenerate occupancy report failed:", error);
          // Náº¿u regenerate fail, chá»‰ refresh data hiá»‡n cÃ³
          fetchData();
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for occupancy report");

    const channel = supabase
      .channel(`occupancy-report-${propertyId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "rooms",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Room created, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "rooms",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Room updated, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "contracts",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Contract created, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "contracts",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Contract updated, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "tenants",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Tenant created, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "tenants",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Tenant updated, refreshing occupancy report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "occupancy_summary",
          filter: `property_id=eq.${propertyId}`,
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: New occupancy summary created");
          // Chá»‰ refresh data, khÃ´ng regenerate
          fetchData();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "occupancy_summary",
          filter: `property_id=eq.${propertyId}`,
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Occupancy summary updated");
          // Chá»‰ refresh data, khÃ´ng regenerate
          fetchData();
        }
      )
      .subscribe((status) => {
        if (status === "SUBSCRIBED") {
          console.log("âœ… Occupancy report realtime connected");
        } else if (status === "CHANNEL_ERROR") {
          console.error("âŒ Occupancy report realtime error");
        }
      });

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up occupancy report realtime subscription");
      clearTimeout(refetchTimeout);
      supabase.removeChannel(channel);
    };
  }, [propertyId]);

  const generateReport = async (reportDate = null) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateOccupancyReport(propertyId, reportDate);

      // Refresh data after generation
      const updatedData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating occupancy report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getOccupancySummary(
        propertyId,
        limit
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing occupancy report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
