import { useState, useEffect, useRef, useCallback } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useMaintenanceReport = (propertyId, periodType = "MONTHLY", limit = 12, autoGenerate = true, dateFilter = null) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);
  const isGeneratingRef = useRef(false);
  const lastPeriodType = useRef(periodType);

  // Reset auto-generate flag when periodType changes
  useEffect(() => {
    if (lastPeriodType.current !== periodType) {
      hasAutoGenerated.current = false;
      isGeneratingRef.current = false;
      lastPeriodType.current = periodType;
    }
  }, [periodType]);

  // Memoize fetchData vá»›i useCallback
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const summaryData = await reportService.getMaintenanceSummary(
        propertyId,
        periodType,
        limit,
        dateFilter
      );

      // Náº¿u propertyId = null (táº¥t cáº£ properties), khÃ´ng cáº§n auto-generate vÃ¬ Ä‘Ã£ tÃ­nh tá»« maintenance table trá»±c tiáº¿p
      // Chá»‰ auto-generate khi propertyId Ä‘Æ°á»£c cung cáº¥p vÃ  chÆ°a cÃ³ dá»¯ liá»‡u
      if (propertyId && (!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current && !isGeneratingRef.current) {
        isGeneratingRef.current = true;
        hasAutoGenerated.current = true;
        
        try {
          const today = new Date();
          const startDate = new Date(today.getFullYear(), today.getMonth(), 1)
            .toISOString()
            .split("T")[0];
          const endDate = today.toISOString().split("T")[0];
          
          await reportService.generateMaintenanceReport(
            propertyId,
            startDate,
            endDate
          );
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getMaintenanceSummary(
            propertyId,
            periodType,
            limit,
            dateFilter
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate maintenance report failed:", genError);
          hasAutoGenerated.current = false;
          // Set data to empty array instead of throwing error
          setData([]);
        } finally {
          isGeneratingRef.current = false;
        }
      } else {
        setData(summaryData || []);
      }
    } catch (err) {
      console.error("Error fetching maintenance report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [propertyId, periodType, limit, autoGenerate, dateFilter]);

  useEffect(() => {
    // Allow fetching when propertyId is null (all properties) or when propertyId is provided
    fetchData();
  }, [fetchData]);

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    let refetchTimeout;
    let isMounted = true; // Track mount status

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      if (!isMounted) return;
      
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        if (!isMounted) return;
        
        // Tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o khi cÃ³ thay Ä‘á»•i (chá»‰ khi cÃ³ propertyId)
        if (propertyId) {
          try {
            const today = new Date();
            const startDate = new Date(today.getFullYear(), today.getMonth(), 1)
              .toISOString()
              .split("T")[0];
            const endDate = today.toISOString().split("T")[0];
            
            await reportService.generateMaintenanceReport(
              propertyId,
              startDate,
              endDate
            );
            
            // Fetch láº¡i sau khi regenerate
            const updatedData = await reportService.getMaintenanceSummary(
              propertyId,
              periodType,
              limit,
              dateFilter
            );
            if (isMounted) {
              setData(updatedData);
            }
          } catch (error) {
            console.error("Auto-regenerate maintenance report failed:", error);
            // Náº¿u regenerate fail, chá»‰ refresh data hiá»‡n cÃ³
            if (isMounted) {
              fetchData();
            }
          }
        } else {
          // For all properties, just refresh data (no regenerate needed)
          if (isMounted) {
            fetchData();
          }
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for maintenance report");

    const channelName = propertyId 
      ? `maintenance-report-${propertyId}`
      : `maintenance-report-all-properties`;
    
    const channel = supabase.channel(channelName);

    // Subscribe to maintenance changes with property filter
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance created, refreshing maintenance report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance updated, refreshing maintenance report");
            debouncedRefetch();
          }
        );
    } else {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance created (all properties), refreshing maintenance report");
            debouncedRefetch();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance updated (all properties), refreshing maintenance report");
            debouncedRefetch();
          }
        );
    }

    // Subscribe to maintenance_requests changes
    // Note: maintenance_requests might not have property_id directly, listen to all
    channel
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "maintenance_requests",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance request created, refreshing maintenance report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "maintenance_requests",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance request updated, refreshing maintenance report");
          debouncedRefetch();
        }
      );

    // Subscribe to maintenance_summary changes
    if (propertyId) {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New maintenance summary created");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance_summary",
            filter: `property_id=eq.${propertyId}`,
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance summary updated");
            fetchData();
          }
        );
    } else {
      channel
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "maintenance_summary",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: New maintenance summary created (all properties)");
            fetchData();
          }
        )
        .on(
          "postgres_changes",
          {
            event: "UPDATE",
            schema: "public",
            table: "maintenance_summary",
          },
          (payload) => {
            console.log("ðŸ”” REALTIME: Maintenance summary updated (all properties)");
            fetchData();
          }
        );
    }

    channel.subscribe((status) => {
      if (status === "SUBSCRIBED") {
        console.log("âœ… Maintenance report realtime connected");
      } else if (status === "CHANNEL_ERROR") {
        console.error("âŒ Maintenance report realtime error");
      }
    });

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up maintenance report realtime subscription");
      isMounted = false;
      clearTimeout(refetchTimeout);
      supabase.removeChannel(channel);
    };
  }, [propertyId, periodType, limit, fetchData, dateFilter]); // Removed propertyId check - now supports all properties

  const generateReport = async (startDate, endDate) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateMaintenanceReport(
        propertyId,
        startDate,
        endDate
      );

      // Refresh data after generation
      const updatedData = await reportService.getMaintenanceSummary(
        propertyId,
        periodType,
        limit,
        dateFilter
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating maintenance report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getMaintenanceSummary(
        propertyId,
        periodType,
        limit,
        dateFilter
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing maintenance report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
