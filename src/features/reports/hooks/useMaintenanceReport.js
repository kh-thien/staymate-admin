import { useState, useEffect, useRef } from "react";
import { reportService } from "../services/reportService";
import { supabase } from "../../../core/data/remote/supabase";

export const useMaintenanceReport = (propertyId, limit = 12, autoGenerate = true) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const hasAutoGenerated = useRef(false);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);

      const summaryData = await reportService.getMaintenanceSummary(
        propertyId,
        limit
      );

      // Náº¿u chÆ°a cÃ³ dá»¯ liá»‡u vÃ  cho phÃ©p auto-generate, tá»± Ä‘á»™ng táº¡o bÃ¡o cÃ¡o
      if ((!summaryData || summaryData.length === 0) && autoGenerate && !hasAutoGenerated.current) {
        hasAutoGenerated.current = true;
        
        try {
          const today = new Date();
          const startDate = new Date(today.getFullYear(), today.getMonth(), 1)
            .toISOString()
            .split("T")[0];
          const endDate = today.toISOString().split("T")[0];
          
          await reportService.generateMaintenanceReport(
            propertyId,
            startDate,
            endDate
          );
          
          // Fetch láº¡i sau khi generate
          const newData = await reportService.getMaintenanceSummary(
            propertyId,
            limit
          );
          setData(newData);
        } catch (genError) {
          console.error("Auto-generate maintenance report failed:", genError);
          setData([]);
        }
      } else {
        setData(summaryData);
      }
    } catch (err) {
      console.error("Error fetching maintenance report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!propertyId) {
      setLoading(false);
      return;
    }

    fetchData();
  }, [propertyId, limit, autoGenerate]);

  // ðŸ”¥ REALTIME SUBSCRIPTION - Tá»± Ä‘á»™ng refresh khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    if (!propertyId) return;

    let refetchTimeout;

    // Debounced refetch Ä‘á»ƒ trÃ¡nh nhiá»u láº§n fetch liÃªn tiáº¿p
    const debouncedRefetch = () => {
      clearTimeout(refetchTimeout);
      refetchTimeout = setTimeout(async () => {
        // Tá»± Ä‘á»™ng regenerate bÃ¡o cÃ¡o khi cÃ³ thay Ä‘á»•i
        try {
          const today = new Date();
          const startDate = new Date(today.getFullYear(), today.getMonth(), 1)
            .toISOString()
            .split("T")[0];
          const endDate = today.toISOString().split("T")[0];
          
          await reportService.generateMaintenanceReport(
            propertyId,
            startDate,
            endDate
          );
          
          // Fetch láº¡i sau khi regenerate
          const updatedData = await reportService.getMaintenanceSummary(
            propertyId,
            limit
          );
          setData(updatedData);
        } catch (error) {
          console.error("Auto-regenerate maintenance report failed:", error);
          // Náº¿u regenerate fail, chá»‰ refresh data hiá»‡n cÃ³
          fetchData();
        }
      }, 2000); // Äá»£i 2 giÃ¢y Ä‘á»ƒ trÃ¡nh regenerate quÃ¡ nhiá»u láº§n
    };

    console.log("ðŸ”” Setting up realtime subscription for maintenance report");

    const channel = supabase
      .channel(`maintenance-report-${propertyId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "maintenance",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance created, refreshing maintenance report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "maintenance",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance updated, refreshing maintenance report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "maintenance_requests",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance request created, refreshing maintenance report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "maintenance_requests",
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance request updated, refreshing maintenance report");
          debouncedRefetch();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "maintenance_summary",
          filter: `property_id=eq.${propertyId}`,
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: New maintenance summary created");
          // Chá»‰ refresh data, khÃ´ng regenerate
          fetchData();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "maintenance_summary",
          filter: `property_id=eq.${propertyId}`,
        },
        (payload) => {
          console.log("ðŸ”” REALTIME: Maintenance summary updated");
          // Chá»‰ refresh data, khÃ´ng regenerate
          fetchData();
        }
      )
      .subscribe((status) => {
        if (status === "SUBSCRIBED") {
          console.log("âœ… Maintenance report realtime connected");
        } else if (status === "CHANNEL_ERROR") {
          console.error("âŒ Maintenance report realtime error");
        }
      });

    // Cleanup subscription on unmount
    return () => {
      console.log("ðŸ”´ Cleaning up maintenance report realtime subscription");
      clearTimeout(refetchTimeout);
      supabase.removeChannel(channel);
    };
  }, [propertyId]);

  const generateReport = async (startDate, endDate) => {
    try {
      setLoading(true);
      setError(null);

      await reportService.generateMaintenanceReport(
        propertyId,
        startDate,
        endDate
      );

      // Refresh data after generation
      const updatedData = await reportService.getMaintenanceSummary(
        propertyId,
        limit
      );
      setData(updatedData);

      return updatedData;
    } catch (err) {
      console.error("Error generating maintenance report:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const refresh = async () => {
    try {
      setLoading(true);
      const updatedData = await reportService.getMaintenanceSummary(
        propertyId,
        limit
      );
      setData(updatedData);
    } catch (err) {
      console.error("Error refreshing maintenance report:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return {
    data,
    loading,
    error,
    generateReport,
    refresh,
  };
};
